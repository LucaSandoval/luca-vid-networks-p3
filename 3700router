#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math

class Router:

    relations = {}
    sockets = {}
    ports = {}

    # Keep track of all recieved route announcements
    route_announcments = []
    # Keep track of all routes in our forwarding table
    forwarding_table = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                # print("Received message '%s' from %s" % (msg, srcif))
                self.process_msg(msg)          
        return
    
    def process_msg(self, msg):
        msg_json = json.loads(msg)
        msg_src = msg_json['src']
        msg_dst = msg_json['dst']
        msg_type = msg_json['type']
        msg_msg = msg_json['msg']
        # msg_msg_json = json.loads(msg_msg)
        print("source: " + msg_src + ", destination: " + msg_dst + ", type: " + msg_type)
        
        # main logic
        if (msg_type == "update"):
            # save a copy of this route announcement for later
            self.route_announcments.append(msg)
            # update our forwarding table
            self.forwarding_table.append(msg_msg)
            # send copies to neighbors (if applicable)
            rec_neighbor_type = self.relations[msg_src]
            for sock_ip in self.sockets:
                # Don't send the update back the way it came
                if(sock_ip != msg_src):
                    # Decide if we're sending a copy to a given neighbor based on peer/cust/prov relationship
                    if (rec_neighbor_type == "cust") or (((rec_neighbor_type == "prov") or (rec_neighbor_type == "peer")) and (self.relations[sock_ip] == "cust")):
                        # Remove private fields from our message
                        new_msg = {
                            "src" : self.our_addr(sock_ip),
                            "dst" : sock_ip,
                            "type" : msg_type,
                            "msg" :
                            {
                                "network" : msg_msg['network'],
                                "netmask" : msg_msg['netmask'],
                                "ASPath" : [self.asn] + msg_msg['ASPath']
                            }
                        }
                        # Send it over our neighbor
                        self.send(sock_ip, json.dumps(new_msg))
        elif(msg_type == "data"):
            print("Trying to send data")
        elif(msg_type == "dump"):
            print("Trying to send data")
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()