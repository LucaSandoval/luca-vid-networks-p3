#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math

class Router:

    relations = {}
    sockets = {}
    ports = {}

    # Keep track of all recieved route announcements
    route_announcments = []
    # Keep track of all routes in our forwarding table
    forwarding_table = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                
                self.process_msg(msg)          
        return
    
    def process_msg(self, msg):
        msg_json = json.loads(msg)
        msg_src = msg_json['src']
        msg_dst = msg_json['dst']
        msg_type = msg_json['type']
        msg_msg = msg_json['msg']
        # msg_msg_json = json.loads(msg_msg)
        print("source: " + msg_src + ", destination: " + msg_dst + ", type: " + msg_type)
        
        # main logic
        if (msg_type == "update"):
            # save a copy of this route announcement for later
            self.route_announcments.append(msg)
            # update our forwarding table
            msg_msg["peer"] = msg_src
            self.forwarding_table.append(msg_msg)
            # send copies to neighbors (if applicable)
            rec_neighbor_type = self.relations[msg_src]
            for sock_ip in self.sockets:
                # Don't send the update back the way it came
                if(sock_ip != msg_src):
                    # Decide if we're sending a copy to a given neighbor based on peer/cust/prov relationship
                    if (rec_neighbor_type == "cust") or (((rec_neighbor_type == "prov") or (rec_neighbor_type == "peer")) and (self.relations[sock_ip] == "cust")):
                        # Remove private fields from our message
                        new_msg = {
                            "src" : self.our_addr(sock_ip),
                            "dst" : sock_ip,
                            "type" : msg_type,
                            "msg" :
                            {
                                "network" : msg_msg['network'],
                                "netmask" : msg_msg['netmask'],
                                "ASPath" : [self.asn] + msg_msg['ASPath']
                            }
                        }
                        # Send it over our neighbor
                        self.send(sock_ip, json.dumps(new_msg))
        elif(msg_type == "data"):
            # Determine if packet is legal
            
            # Determine which route to forward it to (if any)
            for route in self.forwarding_table:
                route_network = route['network']
                route_netmask = route['netmask']
                if self.ip_in_network(msg_dst, route_network, route_netmask):
                    # print("trying to send to: " + route['src'])
                    self.send(route['peer'], msg)
                    return
        elif(msg_type == "dump"):
            # Sends table message back the way it came.
            self.send(msg_src, self.send_table(msg_src))
        return
    
    def ip_in_network(self, ip, network, netmask):
        # Split the IP address, network address, and netmask into octets
        ip_octets = [int(octet) for octet in ip.split('.')]
        network_octets = [int(octet) for octet in network.split('.')]
        netmask_octets = [int(octet) for octet in netmask.split('.')]
        
        # Convert octets to binary
        ip_binary = int(''.join(format(octet, '08b') for octet in ip_octets), 2)
        network_binary = int(''.join(format(octet, '08b') for octet in network_octets), 2)
        netmask_binary = int(''.join(format(octet, '08b') for octet in netmask_octets), 2)

        # Compare if the result matches the network address
        return (network_binary & netmask_binary) == (ip_binary & netmask_binary)
    
    def send_table(self, dst):
        response = {
            "src":  self.our_addr(dst),        # Example: 72.65.0.1, i.e., your router
            "dst":  dst,   # Example: 72.65.0.2, i.e., the neighboring router
            "type": "table",
            "msg": self.forwarding_table
            }
        return json.dumps(response)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()